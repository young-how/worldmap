<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D World Map with Circles</title>
    <style>
        body { margin: 0; }
        canvas { display: block; }
        #menu {
            height: 50px;
            background: rgba(0, 0, 0, 0.5); /* Semi-transparent background */
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            position: fixed;
            bottom: 0;
            width: 100%;
            z-index: 1000; /* Ensure the menu is above the map */
        }
        #menu button {
            background-color: rgba(0, 123, 255, 0.5); /* Semi-transparent button */
            border: none;
            padding: 10px 20px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        #menu button:hover {
            background-color: rgba(0, 123, 255, 0.7); /* Darker on hover */
        }
    </style>
</head>
<body>
<div id="menu">
    <button id="fetchThreats">获取威胁</button>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-geo@0.15.0/ThreeGeo.min.js"></script>
<script src="https://unpkg.com/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three-orbitcontrols@2.110.3/OrbitControls.js"></script>
<script>
    // Initialize Three.js scene
    var scene = new THREE.Scene();
    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Add lighting
    var light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 5, 5).normalize();
    scene.add(light);

    // Initialize controls
    var controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.25;
    controls.enableZoom = true;

    // Initialize ThreeGeo
    var tg = new ThreeGeo({
        radius: 6371, // Earth radius
        depth: 0.5
    });

    // Load the world map
    tg.loadTerrain('world', 8, 1).then((terrain) => {
        scene.add(terrain);
    });

    camera.position.z = 15;

    // Function to add a circle to the map
    function addCircle(lat, lng, radius) {
        var geometry = new THREE.CircleGeometry(radius / 1000, 64); // Adjust radius scale
        var material = new THREE.MeshBasicMaterial({ color: 0x0000ff, transparent: true, opacity: 0.5 });
        var circle = new THREE.Mesh(geometry, material);

        var coords = tg.lonLatToVector3(lng, lat, 6371 + 0.1); // Earth radius plus a small height
        circle.position.set(coords.x, coords.y, coords.z);
        circle.lookAt(new THREE.Vector3(0, 0, 0)); // Ensure circle faces outward
        scene.add(circle);
    }

    // Add default circles around Taiwan
    addCircle(23.5, 121, 200); // Example circle with 200 km radius
    addCircle(24.7, 122.2, 100); // Example circle with 100 km radius

    // Function to fetch and add circles from server
    function fetchCircles() {
        axios.get('https://example.com/api/circle-data') // Replace with your server URL
            .then(response => {
                const circles = response.data;
                circles.forEach(circle => {
                    addCircle(circle.lat, circle.lng, circle.radius);
                });
            })
            .catch(error => {
                console.error('Error fetching circle data:', error);
            });
    }

    // Fetch threats button click event
    document.getElementById('fetchThreats').addEventListener('click', function() {
        axios.get('http://localhost:1025/getThreatens') // Replace with your server URL
            .then(response => {
                const threats = response.data;
                threats.forEach(threat => {
                    addCircle(threat.center_point.latitude, threat.center_point.longitude, threat.R * 1000);
                });
            })
            .catch(error => {
                console.error('Error fetching threat data:', error);
            });
    });

    // Array to hold the latlng points and markers
    var latlngs = [];
    var markers = [];

    // Function to add marker and draw line
    function addMarker(e) {
        var lat = e.lat;
        var lng = e.lng;
        latlngs.push({lat: lat, lng: lng});

        // Add marker (just for visual indication, not draggable in 3D)
        var geometry = new THREE.SphereGeometry(0.05, 32, 32);
        var material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
        var marker = new THREE.Mesh(geometry, material);
        var coords = tg.lonLatToVector3(lng, lat, 6371 + 0.1);
        marker.position.set(coords.x, coords.y, coords.z);
        scene.add(marker);
        markers.push(marker);

        redrawPolyline();
    }

    // Function to remove marker and update line
    function removeMarker(marker) {
        // Removing functionality not shown in 3D example for simplicity
    }

    // Function to redraw the polyline after adding/removing a marker
    function redrawPolyline() {
        // Remove all existing polylines
        var oldLines = scene.children.filter(child => child.type === 'Line');
        oldLines.forEach(line => scene.remove(line));

        if (latlngs.length > 1) {
            var points = latlngs.map(coord => tg.lonLatToVector3(coord.lng, coord.lat, 6371 + 0.1));
            var geometry = new THREE.BufferGeometry().setFromPoints(points);
            var material = new THREE.LineBasicMaterial({ color: 0xff0000 });
            var polyline = new THREE.Line(geometry, material);
            scene.add(polyline);
        }
    }

    // Add double click event to the map to add markers
    renderer.domElement.addEventListener('dblclick', function(event) {
        var mouse = new THREE.Vector2();
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        var raycaster = new THREE.Raycaster();
        raycaster.setFromCamera(mouse, camera);
        var intersects = raycaster.intersectObjects(scene.children, true);

        if (intersects.length > 0) {
            var intersect = intersects[0];
            var latlng = tg.vector3ToLonLat(intersect.point);
            addMarker(latlng);
        }
    });

    // Animate the scene
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    window.addEventListener('resize', function() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });

    // Start animation loop
    animate();
</script>
</body>
</html>
